Phase: ctt
Input: Token Collections Tresors Trouvailles PeriodeEmission NatureMonnaie ANgazetier
Options: control = appelt

Macro: DEBUT
(
    ({Collections}|{Tresors}|{Trouvailles})
)

Macro: CONTENU
(
    ({Token, !Collections, !Tresors, !Trouvailles,!PeriodeEmission,!NatureMonnaie,! ANgazetier.majorType == "ateliers"})+
)

Macro: FIN
(
    ({Collections}|{Tresors}|{Trouvailles}|{ANgazetier.majorType == "ateliers"}|{PeriodeEmission}|{Token.kind =="number"}{NatureMonnaie})
)

//Règles
Rule: CttRule
(
    (DEBUT)
    (CONTENU):contenu
    (FIN)
)
-->
: contenu{
    // Pour trier le contenu dans lordre de parcours
    OffsetComparator comparator            = new OffsetComparator();

    gate.AnnotationSet matchedContenu  = (gate.AnnotationSet)bindings.get("contenu");
    List<Annotation>   listContenu     = new ArrayList<Annotation>(matchedContenu);
    
    Collections.sort(listContenu, comparator);

    String contenu = "";

    //On récupere chaque token séparés par les expaces
    for (Annotation ann :  listContenu) {
      contenu += (String)ann.getFeatures().get("string");
    }

    System.out.println("Contenu : "+ contenu);

    //declaration d'annotation vide
    gate.AnnotationSet matchedInter    = (gate.AnnotationSet)bindings.get("Ctt");

if(matchedInter == null){
    System.out.println("PWOBLEM");
}

    gate.FeatureMap newFeatures        = Factory.newFeatureMap();
     //MAJ de l'annotation initialement vide
    newFeatures.put("Kind","Ctt");
    newFeatures.put("Rule","CttRule");
    newFeatures.put("contenu",contenu);

                //Validation de l'annotation et sortie
    //outputAS.add(matchedInter.firstNode(),matchedInter.lastNode(),"contenu",newFeatures);

}